with open('d19.in1', 'r') as f:
  content = f.read()
l = content.split('\n\n')
rules = [x.replace('\n', '') for x in l[0].split('\n')]
exps = [x.replace('\n', '') for x in l[1].split('\n')]

print()
def matches(inexp):
  i = -1
  print('match:', inexp)
  opstack = []
  argstack = []
  result = 0
  while i < len(inexp) - 1:
    i += 1
    token = inexp[i]
    if ('0' <= token[0] and token[0] <= '9'):
      result = int(token)
      #print('int:', result)
      argstack.append(result)
    elif token == '(':
      nest = 1
      for j in range(i + 1,len(inexp)):
        if inexp[j][0] == '(':
          nest += 1
        if inexp[j][0] == ')':
          nest -= 1
          if nest == 0:
            subeval = inexp[i + 1:j]
            result = evalexp1(subeval)
            #print('subeval:', subeval, ' res = ', result)
            argstack.append(result)
            i = j
            break
    elif token == '+':
      #print('op: +');
      opstack.append('+')
    elif token == '*':
      #print('op: *');
      opstack.append('*')
    if len(argstack) == 2:
      ops = opstack.pop()
      if ops == '+':
        #print('return: ', argstack[0], ' -> ', argstack[0] + argstack[1])
        result = argstack.pop() + argstack.pop()
      elif ops == '*':
        #print('return: ', argstack[0], ' -> ', argstack[0] * argstack[1])
        result = argstack.pop() * argstack.pop()
      argstack.append(result)
  return argstack.pop()  #result  # argstack[0]

for test in exps:
  print(test, '\t', matches(test))
